<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>DSE Web Engine v0.10 — BLK + C16/S16 + ATT Norn Composer</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
body{margin:0;background:#0b1020;color:#e5e7eb;font:14px/1.45 system-ui,Segoe UI,Roboto,Arial}
header{padding:12px 16px;display:flex;gap:12px;align-items:center;background:#0a0f1e;border-bottom:1px solid #1f2937;position:sticky;top:0;z-index:10}
.badge{font-size:12px;padding:2px 8px;border-radius:999px;background:#172554;color:#93c5fd;border:1px solid #1e3a8a}
main{display:grid;grid-template-columns:460px 1fr;gap:12px;padding:12px}
.card{background:#0c1326;border:1px solid #1f2937;border-radius:14px;padding:12px}
h2{font-size:16px;margin:0 0 8px 0;color:#cbd5e1}
.btn{background:#0ea5e9;color:#03111f;border:none;font-weight:700;padding:8px 12px;border-radius:10px;cursor:pointer}
.btn:disabled{opacity:.5;cursor:not-allowed}
.row{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
.pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #334155;color:#93c5fd}
.ok{color:#22c55e}.warn{color:#f59e0b}.bad{color:#ef4444}
.log{white-space:pre-wrap;background:#0b1020;border:1px solid #1f2937;border-radius:12px;padding:10px;min-height:140px}
.small{font-size:12px;color:#93a1b1}
select,input[type=number],input[type=text]{background:#0b1020;color:#e5e7eb;border:1px solid #1e293b;border-radius:8px;padding:6px 8px}
#world{position:relative;width:100%;height:720px;background:#0b132b;border:1px solid #1e293b;border-radius:12px;overflow:hidden}
#bg{position:absolute;left:0;top:0;image-rendering:pixelated}
#grid{position:absolute;left:0;top:0;image-rendering:pixelated}
#stage{position:absolute;left:0;top:0;image-rendering:pixelated}
.agent{position:absolute;user-select:none;cursor:pointer}
.agent .box{position:absolute;border:1px dashed #64748b;inset:0;pointer-events:none}
fieldset{border:1px solid #1f2937;border-radius:10px;padding:8px}
legend{font-size:12px;color:#93a1b1}
</style>
</head>
<body>
<header>
  <div>DSE Web Engine</div>
  <span class="badge">v0.10</span>
  <span class="small">Folder access • BLK background • C16/S16 sprites • ATT body data</span>
</header>

<main>
  <aside class="card">
    <h2>Assets</h2>
    <div class="row">
      <button class="btn" id="pick">Choose Docking Station Folder</button>
      <span id="pickStatus" class="pill">—</span>
    </div>
    <div class="small">Looks for <code>Backgrounds/</code> (.blk), <code>Images/</code> (.c16/.s16), and <code>Body Data/</code> (.att). If not found, scans recursively.</div>

    <h2 style="margin-top:10px">Background (.blk)</h2>
    <div class="row">
      <select id="bgList"></select>
      <button class="btn" id="loadBg" disabled>Load Background</button>
      <span id="bgStatus" class="pill">—</span>
    </div>

    <h2 style="margin-top:10px">Sprite (.c16/.s16)</h2>
    <div class="row">
      <select id="sprList"></select>
      <button class="btn" id="spawnSprite" disabled>Spawn Sprite</button>
      <span id="sprStatus" class="pill">—</span>
    </div>

    <h2 style="margin-top:10px">Norn Composer (.att + sprites)</h2>
    <fieldset>
      <legend>Breed Codes</legend>
      <div class="row">
        <label>Species/Gender
          <select id="sg">
            <option value="0">0 Male Norn</option>
            <option value="4">4 Female Norn</option>
            <option value="1">1 Male Grendel</option>
            <option value="5">5 Female Grendel</option>
            <option value="2">2 Male Ettin</option>
            <option value="6">6 Female Ettin</option>
            <option value="3">3 Male Geat</option>
            <option value="7">7 Female Geat</option>
          </select>
        </label>
        <label>Stage
          <select id="stage">
            <option value="0">0 Baby</option>
            <option value="1">1 Child</option>
            <option value="2">2 Adolescent</option>
            <option value="3">3 Youth</option>
            <option value="4" selected>4 Adult</option>
            <option value="5">5 Aged</option>
            <option value="6">6 Senior</option>
          </select>
        </label>
        <label>Breed Slot <input id="breed" value="a" size="2" maxlength="1"/></label>
      </div>
      <div class="row">
        <label>Pose <input type="number" id="pose" value="0" min="0" max="15" style="width:64px"/></label>
        <button class="btn" id="buildNorn" disabled>Build Norn</button>
        <span id="nornStatus" class="pill">—</span>
      </div>
    </fieldset>

    <h2 style="margin-top:10px">Logs</h2>
    <div id="log" class="log"></div>
  </aside>

  <section class="card">
    <h2>World</h2>
    <div id="world">
      <canvas id="bg"></canvas>
      <canvas id="grid"></canvas>
      <canvas id="stage"></canvas>
    </div>
  </section>
</main>

<script>
const $ = s=>document.querySelector(s);
const log = m=>{ const el=$('#log'); el.textContent += m + "\\n"; el.scrollTop=el.scrollHeight; };

// canvases
const world = $('#world');
const bg = $('#bg'); const bctx = bg.getContext('2d', { willReadFrequently:true });
const grid = $('#grid'); const gctx = grid.getContext('2d', { willReadFrequently:true });
const stage = $('#stage'); const sctx = stage.getContext('2d', { willReadFrequently:true, alpha:true });
function resize(){ bg.width=grid.width=stage.width=world.clientWidth; bg.height=grid.height=stage.height=world.clientHeight; drawGrid(); }
function drawGrid(){ gctx.clearRect(0,0,grid.width,grid.height); gctx.strokeStyle='#18233d'; for(let x=0;x<grid.width;x+=32){gctx.beginPath();gctx.moveTo(x,0);gctx.lineTo(x,grid.height);gctx.stroke();} for(let y=0;y<grid.height;y+=32){gctx.beginPath();gctx.moveTo(0,y);gctx.lineTo(grid.width,y);gctx.stroke();} }
addEventListener('resize', resize); resize();

// FS Access — directory picker and recursive indexing
let rootHandle = null;
let imagesDir = null, backgroundsDir = null, bodyDataDir = null;
const sprites = new Map();      // name -> handle (.c16/.s16)
const backgrounds = new Map();  // name -> handle (.blk)
const bodydata = new Map();     // name -> handle (.att)

async function* walk(dir) {
  for await (const [name, handle] of dir.entries()) {
    if (handle.kind === 'directory') { yield* walk(handle); }
    else { yield [name, handle]; }
  }
}

async function chooseFolder(){
  try{
    rootHandle = await window.showDirectoryPicker();
  }catch(e){
    log('Folder selection cancelled'); return;
  }
  $('#pickStatus').textContent='OK'; $('#pickStatus').classList.add('ok');

  async function getDir(name){
    try{ return await rootHandle.getDirectoryHandle(name); }catch{ return null; }
  }
  imagesDir = await getDir('Images')
      || await getDir('Docking Station')?.then(d=>d.getDirectoryHandle('Images').catch(()=>null)).catch(()=>null);
  backgroundsDir = await getDir('Backgrounds')
      || await getDir('Docking Station')?.then(d=>d.getDirectoryHandle('Backgrounds').catch(()=>null)).catch(()=>null);
  bodyDataDir = await getDir('Body Data')
      || await getDir('Docking Station')?.then(d=>d.getDirectoryHandle('Body Data').catch(()=>null)).catch(()=>null);

  sprites.clear(); backgrounds.clear(); bodydata.clear();
  async function indexDir(dir, acc, exts){
    if(!dir) return;
    for await (const [name, handle] of walk(dir)){
      const low = name.toLowerCase();
      if(exts.some(ext=>low.endsWith(ext))) acc.set(name, handle);
    }
  }
  await indexDir(imagesDir, sprites, ['.c16','.s16']);
  await indexDir(backgroundsDir, backgrounds, ['.blk']);
  await indexDir(bodyDataDir, bodydata, ['.att']);

  // fallback: scan entire tree if needed
  if(sprites.size===0 || backgrounds.size===0 || bodydata.size===0){
    for await (const [name, handle] of walk(rootHandle)){
      const low=name.toLowerCase();
      if(low.endsWith('.c16')||low.endsWith('.s16')) sprites.set(name, handle);
      if(low.endsWith('.blk')) backgrounds.set(name, handle);
      if(low.endsWith('.att')) bodydata.set(name, handle);
    }
  }

  // populate selects
  const bgList = $('#bgList'); const sprList = $('#sprList');
  bgList.innerHTML=''; sprList.innerHTML='';
  [...backgrounds.keys()].sort().forEach(n=>{ const o=document.createElement('option'); o.value=o.textContent=n; bgList.appendChild(o); });
  [...sprites.keys()].sort().forEach(n=>{ const o=document.createElement('option'); o.value=o.textContent=n; sprList.appendChild(o); });
  $('#loadBg').disabled = backgrounds.size===0;
  $('#spawnSprite').disabled = sprites.size===0;
  $('#buildNorn').disabled = (sprites.size===0 || bodydata.size===0);

  log(`Indexed: ${backgrounds.size} background(s), ${sprites.size} sprite file(s), ${bodydata.size} ATT file(s).`);
}
$('#pick').onclick = chooseFolder;

// helpers: read file into ArrayBuffer or text
async function readFile(handle){ const f = await handle.getFile(); return await f.arrayBuffer(); }
async function readText(handle){ const f = await handle.getFile(); return await f.text(); }

// pixel unpackers
function toRGBA555(px){ const r=((px>>10)&31)*255/31, g=((px>>5)&31)*255/31, b=(px&31)*255/31; return [r|0,g|0,b|0,255]; }
function toRGBA565(px){ const r=((px>>11)&31)*255/31, g=((px>>5)&63)*255/63, b=(px&31)*255/31; return [r|0,g|0,b|0,255]; }

// S16 decode (0=555,1=565)
function decodeS16(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength); let p=0;
  const fmt=dv.getUint32(p,true); p+=4; const pix = (fmt===0)? toRGBA555 : (fmt===1)? toRGBA565 : toRGBA565;
  const count=dv.getUint16(p,true); p+=2; const headers=[];
  for(let i=0;i<count;i++){ const off=dv.getUint32(p,true); p+=4; const w=dv.getUint16(p,true); p+=2; const h=dv.getUint16(p,true); p+=2; headers.push({off,w,h}); }
  const imgs=[]; for(const H of headers){ let q=H.off; const id=new ImageData(H.w,H.h);
    for(let i=0;i<H.w*H.h;i++){ const px=dv.getUint16(q,true); q+=2; const [r,g,b,a]=pix(px); const j=i*4; id.data[j]=r; id.data[j+1]=g; id.data[j+2]=b; id.data[j+3]=a; }
    imgs.push(id); } return imgs;
}

// C16 decode (2=555,3=565). Per-line RLE: tag uint16, bit0=type(1=raw,0=transparent); bits1..15=len; 0x0000=end-of-line.
function decodeC16(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength); let p=0;
  const fmt=dv.getUint32(p,true); p+=4; const pix = (fmt===2)? toRGBA555 : (fmt===3)? toRGBA565 : toRGBA565;
  const count=dv.getUint16(p,true); p+=2; const headers=[];
  for(let i=0;i<count;i++){ const off=dv.getUint32(p,true); p+=4; const w=dv.getUint16(p,true); p+=2; const h=dv.getUint16(p,true); p+=2;
    const lineOffsets=[]; for(let y=1;y<h;y++) lineOffsets.push(dv.getUint32(p,true)), p+=4;
    headers.push({off,w,h}); }
  const imgs=[];
  for(const H of headers){
    let q=H.off; const id=new ImageData(H.w,H.h);
    for(let y=0;y<H.h;y++){
      let filled=0;
      for(;;){
        const tag=dv.getUint16(q,true); q+=2;
        if(tag===0) break; // end-of-line
        const runType= tag & 1; const runLen = tag >> 1;
        if(runType===1){ // raw
          for(let i=0;i<runLen;i++){
            const px=dv.getUint16(q,true); q+=2; const [r,g,b,a]=pix(px);
            const j=(y*H.w + filled + i)*4; id.data[j]=r; id.data[j+1]=g; id.data[j+2]=b; id.data[j+3]=a;
          }
        }else{ // transparent
          for(let i=0;i<runLen;i++){ const j=(y*H.w + filled + i)*4; id.data[j+3]=0; }
        }
        filled += runLen;
        if(filled>=H.w) { /* next tag should be EOL */ }
      }
    }
    imgs.push(id);
  }
  return imgs;
}

// BLK decode (column-major tiles; offsets are "minus 4")
function decodeBLK(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength); let p=0;
  const fmt=dv.getUint32(p,true); p+=4; const pix=(fmt===0)?toRGBA555:toRGBA565;
  const bw=dv.getUint16(p,true); p+=2; const bh=dv.getUint16(p,true); p+=2; const num=dv.getUint16(p,true); p+=2;
  const headers=[]; for(let i=0;i<num;i++){ const offMinus4=dv.getUint32(p,true); p+=4; const w=dv.getUint16(p,true); p+=2; const h=dv.getUint16(p,true); p+=2; headers.push({off:offMinus4+4,w,h}); }
  const tiles=[]; for(const H of headers){ let q=H.off; const id=new ImageData(H.w,H.h);
    for(let i=0;i<H.w*H.h;i++){ const px=dv.getUint16(q,true); q+=2; const [r,g,b,a]=toRGBA565(px); const j=i*4; id.data[j]=r; id.data[j+1]=g; id.data[j+2]=b; id.data[j+3]=a; } tiles.push(id); }
  const tileW=headers[0]?.w||128, tileH=headers[0]?.h||128; const bigW=bw*tileW, bigH=bh*tileH;
  const cnv=document.createElement('canvas'); cnv.width=bigW; cnv.height=bigH; const c=cnv.getContext('2d');
  let idx=0; for(let cx=0;cx<bw;cx++){ for(let cy=0;cy<bh;cy++){ const t=tiles[idx++]; if(t) c.putImageData(t, cx*tileW, cy*tileH); } }
  return cnv;
}

// UI: background
$('#loadBg').onclick = async ()=>{
  const name = $('#bgList').value; if(!name){ alert('Pick a .blk'); return; }
  const handle = backgrounds.get(name); const buf = await readFile(handle);
  const cnv = decodeBLK(new Uint8Array(buf));
  bg.width = cnv.width; bg.height = cnv.height;
  bctx.clearRect(0,0,bg.width,bg.height); bctx.drawImage(cnv,0,0);
  $('#bgStatus').textContent='PASS'; $('#bgStatus').classList.add('ok'); log(`Background loaded: ${name} (${bg.width}×${bg.height})`);
};

// Agents & basic sprite demo
let NEXT_ID=1; const agents = new Map();
function place(a){ a.el.style.left=a.x+'px'; a.el.style.top=a.y+'px'; }
function addAgent(x,y,w,h){
  const id=NEXT_ID++; const el=document.createElement('div'); el.className='agent';
  el.style.left=x+'px'; el.style.top=y+'px'; el.style.width=w+'px'; el.style.height=h+'px';
  const box=document.createElement('div'); box.className='box'; el.appendChild(box); world.appendChild(el);
  const a={id,el,x,y,w,h,held:false}; agents.set(id,a);
  el.addEventListener('mousedown', e=>{a.held=true; a.hx=e.offsetX; a.hy=e.offsetY;});
  addEventListener('mousemove', e=>{ if(!a.held) return; const r=world.getBoundingClientRect(); a.x=e.clientX-r.left-a.hx; a.y=e.clientY-r.top-a.hy; place(a); });
  addEventListener('mouseup', ()=>{ if(!a.held) return; a.held=false; });
  place(a); return a;
}

async function decodeSpriteFile(handle){
  const ab = await readFile(handle); const u8=new Uint8Array(ab); const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength); const sig=dv.getUint32(0,true);
  if(sig===2 || sig===3) return decodeC16(u8);
  if(sig===0 || sig===1) return decodeS16(u8);
  throw new Error('Unknown sprite signature: '+sig);
}
$('#spawnSprite').onclick = async ()=>{
  const name = $('#sprList').value; if(!name){ alert('Pick a .c16/.s16'); return; }
  const handle = sprites.get(name);
  try{
    const frames = await decodeSpriteFile(handle);
    const w = frames[0].width, h = frames[0].height;
    const a = addAgent(80,80,w,h);
    let i=0; const cnv=document.createElement('canvas'); cnv.width=w; cnv.height=h; const c=cnv.getContext('2d');
    function step(){ c.putImageData(frames[i%frames.length],0,0); const url=cnv.toDataURL(); a.el.style.background=`url(${url})`; a.el.style.backgroundSize='cover'; i++; }
    step(); a.timer=setInterval(step, 160);
    $('#sprStatus').textContent='PASS'; $('#sprStatus').classList.add('ok'); log(`Spawned sprite ${name} with ${frames.length} frame(s).`);
  }catch(err){ log('Sprite load error: '+err.message); $('#sprStatus').textContent='FAIL'; $('#sprStatus').classList.add('bad'); }
};

// --- ATT support: parse + compose full Norn ---

// Map letters to part chains used in DS (A..N)
const PARTS = {
  A:'head', B:'body',
  C:'lthigh', D:'lshin', E:'lfoot',
  F:'rthigh', G:'rshin', H:'rfoot',
  I:'lupper', J:'lfore',
  K:'rupper', L:'rfore',
  M:'tail1',  N:'tail2'
};
// BodyData B anchors order (6 pairs): head, left leg, right leg, left arm, right arm, tail
const BODY_ANCHORS = ['head','legL','legR','armL','armR','tail'];

// Cache decoded sprite frames and parsed ATTs
const spriteCache = new Map(); // key -> ImageData[]
const attCache = new Map();    // key -> parsed rows

function keyFor(fname){ return fname.toLowerCase(); }

async function loadFramesFor(base){
  // base like 'a04d' (no extension). Prefer .c16 then .s16
  const c16 = base+'.c16', s16=base+'.s16';
  if(spriteCache.has(base)) return spriteCache.get(base);
  const h = sprites.get(c16) || sprites.get(c16.toUpperCase()) || sprites.get(s16) || sprites.get(s16.toUpperCase());
  if(!h) throw new Error('Missing sprite '+base+'.c16/.s16');
  const frames = await decodeSpriteFile(h); spriteCache.set(base, frames); return frames;
}
async function loadATT(base){
  // base like 'a04d' (no extension)
  if(attCache.has(base)) return attCache.get(base);
  const name = base+'.att';
  let h = bodydata.get(name) || bodydata.get(name.toUpperCase());
  if(!h){
    // Some packs may have upper/lowercase letters or alternate naming; try brute-force by map
    for(const k of bodydata.keys()){ if(k.toLowerCase()===name.toLowerCase()){ h=bodydata.get(k); break; } }
  }
  if(!h) throw new Error('Missing ATT '+name);
  const txt = await readText(h);
  const rows = txt.split(/\r?\n/).map(line=>line.trim()).filter(line=>line.length>0 && !line.startsWith('#'));
  const parsed = rows.map(line => line.split(/\s+/).map(n=>parseInt(n,10)));
  attCache.set(base, parsed);
  return parsed;
}

// Build code "SGSB": A (part) + sg (0..7) + stage(0..6) + breed letter a..z
function code(part, sg, stage, breed){
  return (part + String(sg) + String(stage) + String(breed)).toLowerCase();
}

// Draw ImageData to stage at offset
function blit(img, x, y){
  const cnv = document.createElement('canvas'); cnv.width=img.width; cnv.height=img.height; const c=cnv.getContext('2d');
  c.putImageData(img, 0, 0); sctx.drawImage(cnv, x|0, y|0);
}

// Compose a Norn at center using ATT anchors. Pose index p (0..15 for DS)
async function composeNorn(sg, stageIdx, breed, poseIdx){
  sctx.clearRect(0,0,stage.width,stage.height);
  const cx = (stage.width/2)|0, cy = (stage.height*0.65)|0; // ground-ish anchor

  // Load body first
  const bodyBase = code('b', sg, stageIdx, breed);
  const bodyFrames = await loadFramesFor(bodyBase);
  const bodyATT = await loadATT(bodyBase);
  if(poseIdx<0 || poseIdx>=bodyFrames.length){ poseIdx = 0; }
  const bodyImg = bodyFrames[poseIdx];
  // body anchor points (12 numbers => 6 pairs)
  const bRow = bodyATT[poseIdx] || [];
  function pair(row,i){ return {x: (row[i*2]||0), y:(row[i*2+1]||0)}; }
  const B = {
    head: pair(bRow,0),
    legL: pair(bRow,1),
    legR: pair(bRow,2),
    armL: pair(bRow,3),
    armR: pair(bRow,4),
    tail: pair(bRow,5)
  };
  const bodyX = cx - (bodyImg.width/2)|0;
  const bodyY = cy - (bodyImg.height)|0;
  blit(bodyImg, bodyX, bodyY);

  // helper to place a part by aligning its "start" (or custom) to a target point
  async function placePart(partLetter, targetPt){
    const base = code(partLetter.toLowerCase(), sg, stageIdx, breed);
    const frames = await loadFramesFor(base);
    const att = await loadATT(base);
    const img = frames[poseIdx] || frames[0];
    const row = att[poseIdx] || att[0] || [];
    // for limbs C..N, row = [sx,sy, ex,ey]; for A (head), row[0..1] is "limbdata start"
    const sx = row[0]|0, sy = row[1]|0;
    const ox = bodyX + targetPt.x - sx;
    const oy = bodyY + targetPt.y - sy;
    blit(img, ox, oy);
    return {end:{x: (bodyX + targetPt.x - sx + (row[2]||sx)), y:(bodyY + targetPt.y - sy + (row[3]||sy))}};
  }

  // Head (A.start -> B.head)
  try{
    await placePart('a', B.head);
  }catch(e){ log('Head missing: '+e.message); }

  // Left leg chain: C.start -> B.legL ; D.start -> C.end ; E.start -> D.end
  try{
    const c = await placePart('c', B.legL);
    const d = await placePart('d', {x:c.end.x - bodyX, y:c.end.y - bodyY}); // end relative to body origin
    await placePart('e', {x:d.end.x - bodyX, y:d.end.y - bodyY});
  }catch(e){ log('Left leg part missing: '+e.message); }

  // Right leg chain
  try{
    const f = await placePart('f', B.legR);
    const g = await placePart('g', {x:f.end.x - bodyX, y:f.end.y - bodyY});
    await placePart('h', {x:g.end.x - bodyX, y:g.end.y - bodyY});
  }catch(e){ log('Right leg part missing: '+e.message); }

  // Left arm chain
  try{
    const i = await placePart('i', B.armL);
    await placePart('j', {x:i.end.x - bodyX, y:i.end.y - bodyY});
  }catch(e){ log('Left arm part missing: '+e.message); }

  // Right arm chain
  try{
    const k = await placePart('k', B.armR);
    await placePart('l', {x:k.end.x - bodyX, y:k.end.y - bodyY});
  }catch(e){ log('Right arm part missing: '+e.message); }

  // Tail chain
  try{
    const m = await placePart('m', B.tail);
    await placePart('n', {x:m.end.x - bodyX, y:m.end.y - bodyY});
  }catch(e){ log('Tail part missing: '+e.message); }

  $('#nornStatus').textContent='PASS'; $('#nornStatus').classList.add('ok');
  log(`Composed Norn pose ${poseIdx} for sg=${sg} stage=${stageIdx} breed=${breed}`);
}

$('#buildNorn').onclick = async ()=>{
  try{
    const sg = parseInt($('#sg').value,10);
    const stageIdx = parseInt($('#stage').value,10);
    const breed = ($('#breed').value||'a').toLowerCase().charAt(0);
    const poseIdx = parseInt($('#pose').value,10) || 0;
    await composeNorn(sg, stageIdx, breed, poseIdx);
  }catch(err){
    $('#nornStatus').textContent='FAIL'; $('#nornStatus').classList.add('bad');
    log('Norn compose error: '+err.message);
  }
};

log('v0.10 ready — pick your Docking Station folder, then load a background and Build Norn.');
</script>
</body>
</html>
