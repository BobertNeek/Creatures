<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>DSE Web Engine v0.11 — CAOS core + BLK/C16/S16/ATT</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
body{margin:0;background:#0b1020;color:#e5e7eb;font:14px/1.5 system-ui,Segoe UI,Roboto,Arial}
header{padding:12px 16px;display:flex;gap:12px;align-items:center;background:#0a0f1e;border-bottom:1px solid #1f2937;position:sticky;top:0;z-index:10}
.badge{font-size:12px;padding:2px 8px;border-radius:999px;background:#172554;color:#93c5fd;border:1px solid #1e3a8a}
main{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px}
.card{background:#0c1326;border:1px solid #1f2937;border-radius:14px;padding:12px}
h2{font-size:16px;margin:0 0 8px 0;color:#cbd5e1}
.btn{background:#0ea5e9;color:#03111f;border:none;font-weight:700;padding:8px 12px;border-radius:10px;cursor:pointer}
.row{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
.pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #334155;color:#93c5fd}
.ok{color:#22c55e}.warn{color:#f59e0b}.bad{color:#ef4444}
.log{white-space:pre-wrap;background:#0b1020;border:1px solid #1f2937;border-radius:12px;padding:10px;min-height:120px;max-height:260px;overflow:auto}
.small{font-size:12px;color:#93a1b1}
select,input[type=number],input[type=text],textarea{background:#0b1020;color:#e5e7eb;border:1px solid #1e293b;border-radius:8px;padding:6px 8px}
#world{position:relative;width:100%;height:720px;background:#0b132b;border:1px solid #1e293b;border-radius:12px;overflow:hidden}
#bg{position:absolute;left:0;top:0;image-rendering:pixelated}
#grid{position:absolute;left:0;top:0;image-rendering:pixelated}
#stage{position:absolute;left:0;top:0;image-rendering:pixelated}
.agent{position:absolute;user-select:none;cursor:pointer}
.agent .box{position:absolute;border:1px dashed #64748b;inset:0;pointer-events:none}
fieldset{border:1px solid #1f2937;border-radius:10px;padding:8px}
legend{font-size:12px;color:#93a1b1}
#pickInput{position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0}
textarea{width:100%;min-height:160px}
kbd{background:#111827;border:1px solid #1f2937;border-bottom-color:#0f172a;border-radius:6px;padding:1px 6px;font-size:12px}
</style>
</head>
<body>
<header>
  <div>DSE Web Engine</div>
  <span class="badge">v0.11</span>
  <span class="small">CAOS core • BLK • C16/S16 • ATT</span>
</header>

<main>
  <aside class="card">
    <h2>Assets</h2>
    <div class="row">
      <button class="btn" id="pickFS" type="button">Choose Docking Station Folder</button>
      <input id="pickInput" type="file" webkitdirectory multiple />
      <button class="btn" id="pickFallback" type="button">Use Fallback Picker</button>
      <span id="pickStatus" class="pill">—</span>
    </div>
    <div class="small" id="contextHint"></div>

    <h2 style="margin-top:10px">Background (.blk)</h2>
    <div class="row">
      <select id="bgList"></select>
      <button class="btn" id="loadBg" disabled>Load Background</button>
      <span id="bgStatus" class="pill">—</span>
    </div>

    <h2 style="margin-top:10px">Sprite (.c16/.s16)</h2>
    <div class="row">
      <select id="sprList"></select>
      <button class="btn" id="spawnSprite" disabled>Spawn Sprite</button>
      <span id="sprStatus" class="pill">—</span>
    </div>

    <h2 style="margin-top:10px">Norn Composer (.att + sprites)</h2>
    <fieldset>
      <legend>Breed Codes</legend>
      <div class="row">
        <label>Species/Gender
          <select id="sg">
            <option value="0">0 Male Norn</option>
            <option value="4">4 Female Norn</option>
            <option value="1">1 Male Grendel</option>
            <option value="5">5 Female Grendel</option>
            <option value="2">2 Male Ettin</option>
            <option value="6">6 Female Ettin</option>
            <option value="3">3 Male Geat</option>
            <option value="7">7 Female Geat</option>
          </select>
        </label>
        <label>Stage
          <select id="stageSel">
            <option value="0">0 Baby</option>
            <option value="1">1 Child</option>
            <option value="2">2 Adolescent</option>
            <option value="3">3 Youth</option>
            <option value="4" selected>4 Adult</option>
            <option value="5">5 Aged</option>
            <option value="6">6 Senior</option>
          </select>
        </label>
        <label>Breed Slot <input id="breed" value="a" size="2" maxlength="1"/></label>
      </div>
      <div class="row">
        <label>Pose <input type="number" id="pose" value="0" min="0" max="15" style="width:64px"/></label>
        <button class="btn" id="buildNorn" disabled>Build Norn</button>
        <span id="nornStatus" class="pill">—</span>
      </div>
    </fieldset>

    <h2 style="margin-top:10px">CAOS</h2>
    <fieldset>
      <legend>Console & Loader</legend>
      <div class="row">
        <button class="btn" id="runOne">Run Line</button>
        <button class="btn" id="runBlk">Run Block</button>
        <input id="cosFile" type="file" accept=".cos,.txt"/>
      </div>
      <div class="small">Tip: paste agent scripts headed by <kbd>scrp f g s ev</kbd> … <kbd>endm</kbd>. Use <kbd>mesg writ</kbd>, <kbd>targ</kbd>, <kbd>own</kbd>, <kbd>enum</kbd>, <kbd>near</kbd>. <kbd>tick</kbd> enables <kbd>9</kbd> (Timer).</div>
      <textarea id="caos"></textarea>
      <div id="caosLog" class="log"></div>
    </fieldset>

    <h2 style="margin-top:10px">Logs</h2>
    <div id="log" class="log"></div>
  </aside>

  <section class="card">
    <h2>World</h2>
    <div id="world">
      <canvas id="bg"></canvas>
      <canvas id="grid"></canvas>
      <canvas id="stage"></canvas>
    </div>
  </section>
</main>

<script>
const $ = s=>document.querySelector(s);
const log = m=>{ const el=$('#log'); el.textContent += m + "\\n"; el.scrollTop=el.scrollHeight; };
const clog = m=>{ const el=$('#caosLog'); el.textContent += m + "\\n"; el.scrollTop=el.scrollHeight; };

// canvases
const world = $('#world');
const bg = $('#bg'); const bctx = bg.getContext('2d', { willReadFrequently:true });
const grid = $('#grid'); const gctx = grid.getContext('2d', { willReadFrequently:true });
const stage = $('#stage'); const sctx = stage.getContext('2d', { willReadFrequently:true, alpha:true });
function resize(){ bg.width=grid.width=stage.width=world.clientWidth; bg.height=grid.height=stage.clientHeight||world.clientHeight; drawGrid(); }
function drawGrid(){ gctx.clearRect(0,0,grid.width,grid.height); gctx.strokeStyle='#18233d';
  for(let x=0;x<grid.width;x+=32){gctx.beginPath();gctx.moveTo(x,0);gctx.lineTo(x,grid.height);gctx.stroke();}
  for(let y=0;y<grid.height;y+=32){gctx.beginPath();gctx.moveTo(0,y);gctx.lineTo(grid.width,y);gctx.stroke();}
}
addEventListener('resize', resize); setTimeout(resize,0);

// Providers
let provider = null;

const store = {
  sprites: new Map(),
  backgrounds: new Map(),
  bodydata: new Map(),
};

function clearStore(){
  store.sprites.clear(); store.backgrounds.clear(); store.bodydata.clear();
  $('#bgList').innerHTML = ''; $('#sprList').innerHTML='';
  $('#loadBg').disabled = true; $('#spawnSprite').disabled = true; $('#buildNorn').disabled = true;
}

function addToSelect(sel, keys){
  sel.innerHTML=''; keys.sort().forEach(n=>{ const o=document.createElement('option'); o.value=o.textContent=n; sel.appendChild(o); });
}

function setPickStatus(txt, cls){ const ps=$('#pickStatus'); ps.textContent=txt; ps.className='pill'; if(cls) ps.classList.add(cls); }

const supportsFS = 'showDirectoryPicker' in window;
$('#contextHint').textContent = (supportsFS? 'Directory picker available.' : 'Directory picker not available in this browser; use fallback.' )
 + (window.isSecureContext? '' : ' This page is not in a secure context; some browsers will block directory access.');

async function pickFS(){
  if(!supportsFS){ log('FSAccess not supported; use fallback.'); setPickStatus('No API','bad'); return; }
  try{
    const handle = await window.showDirectoryPicker({ mode:'read' });
    provider = await makeFSProvider(handle);
    await indexAll();
    setPickStatus('OK','ok');
  }catch(e){
    log('showDirectoryPicker error: '+ (e && e.message ? e.message : e));
    setPickStatus('FAIL','bad');
  }
}
$('#pickFS').addEventListener('click', pickFS);
$('#pickFallback').addEventListener('click', ()=> $('#pickInput').click(), {passive:true});
$('#pickInput').addEventListener('change', async (ev)=>{
  const files = Array.from(ev.target.files||[]);
  if(files.length===0){ log('No files selected.'); setPickStatus('—'); return; }
  provider = makeFallbackProvider(files);
  await indexAll();
  setPickStatus('OK (fallback)','ok');
});

async function makeFSProvider(rootHandle){
  async function* walk(dir){
    for await (const [name, handle] of dir.entries()){
      if(handle.kind==='directory'){ yield* walk(handle); }
      else { yield [name, handle]; }
    }
  }
  return {
    mode:'fs',
    async listFiles(){
      const out=[];
      for await (const [name, handle] of walk(rootHandle)){
        out.push({name, handle});
      }
      return out;
    },
    async getFile(entry){ const f = await entry.handle.getFile(); return f; }
  };
}
function makeFallbackProvider(files){
  const map = new Map();
  for(const f of files){
    const k = f.webkitRelativePath || f.name;
    map.set(k, f);
  }
  return {
    mode:'fallback',
    async listFiles(){ return Array.from(map, ([name,file]) => ({name, file})); },
    async getFile(entry){ return entry.file; }
  };
}

function nameOf(path){ return path.split('/').pop(); }

async function indexAll(){
  clearStore();
  const entries = await provider.listFiles();
  let nB=0, nS=0, nA=0;
  for(const ent of entries){
    const low = ent.name.toLowerCase();
    if(low.endsWith('.blk')){ store.backgrounds.set(nameOf(ent.name), ent); nB++; }
    else if(low.endsWith('.c16')||low.endsWith('.s16')){ store.sprites.set(nameOf(ent.name), ent); nS++; }
    else if(low.endsWith('.att')){ store.bodydata.set(nameOf(ent.name), ent); nA++; }
  }
  addToSelect($('#bgList'), Array.from(store.backgrounds.keys()));
  addToSelect($('#sprList'), Array.from(store.sprites.keys()));
  $('#loadBg').disabled = store.backgrounds.size===0;
  $('#spawnSprite').disabled = store.sprites.size===0;
  $('#buildNorn').disabled = (store.sprites.size===0 || store.bodydata.size===0);
  log(`Indexed ${nB} .blk, ${nS} sprite(s), ${nA} .att file(s). Mode=${provider.mode}`);
}

async function readArrayBuffer(ent){ const f = await provider.getFile(ent); return await f.arrayBuffer(); }
async function readText(ent){ const f = await provider.getFile(ent); return await f.text(); }

// Pixel helpers
function toRGBA555(px){ const r=((px>>10)&31)*255/31, g=((px>>5)&31)*255/31, b=(px&31)*255/31; return [r|0,g|0,b|0,255]; }
function toRGBA565(px){ const r=((px>>11)&31)*255/31, g=((px>>5)&63)*255/63, b=(px&31)*255/31; return [r|0,g|0,b|0,255]; }

function decodeS16(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength); let p=0;
  const fmt=dv.getUint32(p,true); p+=4; const pix = (fmt===0)? toRGBA555 : (fmt===1)? toRGBA565 : toRGBA565;
  const count=dv.getUint16(p,true); p+=2; const headers=[];
  for(let i=0;i<count;i++){ const off=dv.getUint32(p,true); p+=4; const w=dv.getUint16(p,true); p+=2; const h=dv.getUint16(p,true); p+=2; headers.push({off,w,h}); }
  const imgs=[]; for(const H of headers){ let q=H.off; const id=new ImageData(H.w,H.h);
    for(let i=0;i<H.w*H.h;i++){ const px=dv.getUint16(q,true); q+=2; const [r,g,b,a]=pix(px); const j=i*4; id.data[j]=r; id.data[j+1]=g; id.data[j+2]=b; id.data[j+3]=a; }
    imgs.push(id); } return imgs;
}
function decodeC16(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength); let p=0;
  const fmt=dv.getUint32(p,true); p+=4; const pix = (fmt===2)? toRGBA555 : (fmt===3)? toRGBA565 : toRGBA565;
  const count=dv.getUint16(p,true); p+=2; const headers=[];
  for(let i=0;i<count;i++){
    const off=dv.getUint32(p,true); p+=4; const w=dv.getUint16(p,true); p+=2; const h=dv.getUint16(p,true); p+=2;
    for(let y=1;y<h;y++){ dv.getUint32(p,true); p+=4; }
    headers.push({off,w,h});
  }
  const imgs=[];
  for(const H of headers){
    let q=H.off; const id=new ImageData(H.w,H.h);
    for(let y=0;y<H.h;y++){
      let x=0;
      for(;;){
        const tag=dv.getUint16(q,true); q+=2;
        if(tag===0) break;
        const runType = tag & 1;
        const runLen  = tag >> 1;
        if(runType===1){
          for(let i=0;i<runLen;i++){
            const px=dv.getUint16(q,true); q+=2; const [r,g,b,a]=pix(px);
            const j=(y*H.w + x + i)*4; id.data[j]=r; id.data[j+1]=g; id.data[j+2]=b; id.data[j+3]=a;
          }
        }else{
          for(let i=0;i<runLen;i++){ const j=(y*H.w + x + i)*4; id.data[j+3]=0; }
        }
        x += runLen;
      }
    }
    imgs.push(id);
  }
  return imgs;
}
function decodeBLK(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength); let p=0;
  const fmt=dv.getUint32(p,true); p+=4;
  const bw=dv.getUint16(p,true); p+=2; const bh=dv.getUint16(p,true); p+=2; const num=dv.getUint16(p,true); p+=2;
  const headers=[]; for(let i=0;i<num;i++){ const offMinus4=dv.getUint32(p,true); p+=4; const w=dv.getUint16(p,true); p+=2; const h=dv.getUint16(p,true); p+=2; headers.push({off:offMinus4+4,w,h}); }
  const tiles=[]; for(const H of headers){ let q=H.off; const id=new ImageData(H.w,H.h);
    for(let i=0;i<H.w*H.h;i++){ const px=dv.getUint16(q,true); q+=2; const [r,g,b,a]=toRGBA565(px); const j=i*4; id.data[j]=r; id.data[j+1]=g; id.data[j+2]=b; id.data[j+3]=a; } tiles.push(id); }
  const tileW=headers[0]?.w||128, tileH=headers[0]?.h||128; const bigW=bw*tileW, bigH=bh*tileH;
  const cnv=document.createElement('canvas'); cnv.width=bigW; cnv.height=bigH; const c=cnv.getContext('2d');
  let idx=0; for(let cx=0;cx<bw;cx++){ for(let cy=0;cy<bh;cy++){ const t=tiles[idx++]; if(t) c.putImageData(t, cx*tileW, cy*tileH); } }
  return cnv;
}

// Background UI
$('#loadBg').onclick = async ()=>{
  const name = $('#bgList').value; if(!name){ alert('Pick a .blk'); return; }
  const ent = store.backgrounds.get(name);
  const buf = await readArrayBuffer(ent);
  const cnv = decodeBLK(new Uint8Array(buf));
  bg.width = cnv.width; bg.height = cnv.height;
  bctx.clearRect(0,0,bg.width,bg.height); bctx.drawImage(cnv,0,0);
  $('#bgStatus').textContent='PASS'; $('#bgStatus').classList.add('ok');
  log(`Background loaded: ${name} (${bg.width}×${bg.height})`);
};

// Sprite demo + agents
let NEXT_ID=1; const agents = new Map();
function place(a){ a.el.style.left=a.x+'px'; a.el.style.top=a.y+'px'; }
function addAgent(x,y,w,h){
  const id=NEXT_ID++; const el=document.createElement('div'); el.className='agent';
  el.style.left=x+'px'; el.style.top=y+'px'; el.style.width=w+'px'; el.style.height=h+'px';
  const box=document.createElement('div'); box.className='box'; el.appendChild(box); world.appendChild(el);
  const a={id,el,x,y,w,h,held:false, tick:0, attrs:0, classifier:[2,0,0]}; // default SIMP classifier family 2
  agents.set(id,a);
  el.addEventListener('mousedown', e=>{ dispatchEventTo(a, 3, 0,0); }); // Hit
  el.addEventListener('mousedown', e=>{ a.held=true; a.hx=e.offsetX; a.hy=e.offsetY; dispatchEventTo(a, 4, 0,0); }); // Pickup
  addEventListener('mousemove', e=>{ if(!a.held) return; const r=world.getBoundingClientRect(); a.x=e.clientX-r.left-a.hx; a.y=e.clientY-r.top-a.hy; place(a); });
  addEventListener('mouseup', ()=>{ if(!a.held) return; a.held=false; dispatchEventTo(a, 5, 0,0); }); // Drop
  place(a); return a;
}

function pickDecoder(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength); const sig=dv.getUint32(0,true);
  if(sig===2 || sig===3) return decodeC16(u8);
  if(sig===0 || sig===1) return decodeS16(u8);
  throw new Error('Unknown sprite signature: '+sig);
}
$('#spawnSprite').onclick = async ()=>{
  const name = $('#sprList').value; if(!name){ alert('Pick a .c16/.s16'); return; }
  const ent = store.sprites.get(name);
  try{
    const frames = pickDecoder(new Uint8Array(await readArrayBuffer(ent)));
    const w=frames[0].width, h=frames[0].height;
    const a = addAgent(80,80,w,h);
    a.frames = frames; a.frameIdx = 0;
    const cnv=document.createElement('canvas'); cnv.width=w; cnv.height=h; const c=cnv.getContext('2d');
    function step(){ c.putImageData(frames[a.frameIdx%frames.length],0,0); a.el.style.background=`url(${cnv.toDataURL()})`; a.el.style.backgroundSize='cover'; a.frameIdx++; }
    step(); a.animTimer=setInterval(step, 160);
    $('#sprStatus').textContent='PASS'; $('#sprStatus').classList.add('ok');
    log(`Spawned sprite ${name} with ${frames.length} frame(s). ID=${a.id}`);
  }catch(err){ log('Sprite load error: '+err.message); $('#sprStatus').textContent='FAIL'; $('#sprStatus').classList.add('bad'); }
};

// ATT + Composer
const spriteCache = new Map();
const attCache = new Map();
function code(part, sg, stage, breed){ return (part + String(sg) + String(stage) + String(breed)).toLowerCase(); }
async function loadFramesFor(base){
  if(spriteCache.has(base)) return spriteCache.get(base);
  const variants=[base+'.c16', base+'.C16', base+'.s16', base+'.S16'];
  let ent=null;
  for(const k of variants){ if(store.sprites.has(k)) { ent=store.sprites.get(k); break; } }
  if(!ent){
    for(const k of store.sprites.keys()){ if(k.toLowerCase().startsWith(base.toLowerCase())) { ent=store.sprites.get(k); break; } }
  }
  if(!ent) throw new Error('Missing sprite '+base+'.c16/.s16');
  const frames = pickDecoder(new Uint8Array(await readArrayBuffer(ent)));
  spriteCache.set(base, frames); return frames;
}
async function loadATT(base){
  if(attCache.has(base)) return attCache.get(base);
  const name = base + '.att';
  let ent = store.bodydata.get(name) || store.bodydata.get(name.toUpperCase());
  if(!ent){
    for(const k of store.bodydata.keys()){ if(k.toLowerCase()===name.toLowerCase()){ ent=store.bodydata.get(k); break; } }
  }
  if(!ent) throw new Error('Missing ATT '+name);
  const rows = (await readText(ent)).split(/\r?\n/).map(l=>l.trim()).filter(l=>l && !l.startsWith('#')).map(l=>l.split(/\s+/).map(n=>parseInt(n,10)));
  attCache.set(base, rows); return rows;
}

function blit(img, x, y){ const cnv=document.createElement('canvas'); cnv.width=img.width; cnv.height=img.height; const c=cnv.getContext('2d'); c.putImageData(img,0,0); sctx.drawImage(cnv, x|0, y|0); }

async function composeNorn(sg, stageIdx, breed, poseIdx){
  sctx.clearRect(0,0,stage.width,stage.height);
  const cx = (stage.width/2)|0, cy = (stage.height*0.65)|0;

  const bodyBase = code('b', sg, stageIdx, breed);
  const bodyFrames = await loadFramesFor(bodyBase);
  const bodyATT = await loadATT(bodyBase);
  if(poseIdx<0 || poseIdx>=bodyFrames.length) poseIdx=0;
  const bodyImg = bodyFrames[poseIdx];
  const bRow = bodyATT[poseIdx] || [];
  const bodyX = cx - (bodyImg.width/2)|0;
  const bodyY = cy - (bodyImg.height)|0;
  blit(bodyImg, bodyX, bodyY);
  function pair(row,i){ return {x: (row[i*2]||0), y:(row[i*2+1]||0)}; }
  const B = { head: pair(bRow,0), legL: pair(bRow,1), legR: pair(bRow,2), armL: pair(bRow,3), armR: pair(bRow,4), tail: pair(bRow,5) };

  async function placePart(partLetter, targetPt){
    const base = code(partLetter.toLowerCase(), sg, stageIdx, breed);
    const frames = await loadFramesFor(base);
    const att = await loadATT(base);
    const img = frames[poseIdx] || frames[0];
    const row = att[poseIdx] || att[0] || [];
    const sx = row[0]|0, sy = row[1]|0;
    const ox = bodyX + targetPt.x - sx;
    const oy = bodyY + targetPt.y - sy;
    blit(img, ox, oy);
    return {end:{x: (ox + (row[2]||sx)), y:(oy + (row[3]||sy))}};
  }

  try{ await placePart('a', B.head); }catch(e){ log('Head missing: '+e.message); }
  try{ const c=await placePart('c', B.legL); const d=await placePart('d', {x:c.end.x-bodyX, y:c.end.y-bodyY}); await placePart('e', {x:d.end.x-bodyX, y:d.end.y-bodyY}); }catch(e){ log('Left leg missing: '+e.message); }
  try{ const f=await placePart('f', B.legR); const g=await placePart('g', {x:f.end.x-bodyX, y:f.end.y-bodyY}); await placePart('h', {x:g.end.x-bodyX, y:g.end.y-bodyY}); }catch(e){ log('Right leg missing: '+e.message); }
  try{ const i=await placePart('i', B.armL); await placePart('j', {x:i.end.x-bodyX, y:i.end.y-bodyY}); }catch(e){ log('Left arm missing: '+e.message); }
  try{ const k=await placePart('k', B.armR); await placePart('l', {x:k.end.x-bodyX, y:k.end.y-bodyY}); }catch(e){ log('Right arm missing: '+e.message); }
  try{ const m=await placePart('m', B.tail); await placePart('n', {x:m.end.x-bodyX, y:m.end.y-bodyY}); }catch(e){ log('Tail missing: '+e.message); }

  $('#nornStatus').textContent='PASS'; $('#nornStatus').classList.add('ok');
  log(`Composed Norn pose ${poseIdx} for sg=${sg} stage=${stageIdx} breed=${breed}`);
}
$('#buildNorn').onclick = async ()=>{
  try{
    const sg = parseInt($('#sg').value,10);
    const stageIdx = parseInt($('#stageSel').value,10);
    const breed = ($('#breed').value||'a').toLowerCase().charAt(0);
    const poseIdx = parseInt($('#pose').value,10) || 0;
    await composeNorn(sg, stageIdx, breed, poseIdx);
  }catch(err){
    $('#nornStatus').textContent='FAIL'; $('#nornStatus').classList.add('bad');
    log('Norn compose error: '+err.message);
  }
};

// ===================== CAOS RUNTIME =====================
const Scriptorium = new Map(); // key: "f.g.s.ev" -> [{op,args}, ...]
const EventNames = {0:'Deactivate',1:'Activate1',2:'Activate2',3:'Hit',4:'Pickup',5:'Drop',6:'Collision',9:'Timer',12:'Eaten'};
const VMState = { // global-ish execution context for simple interpreter
  targ: null,
  own: null,
  from: null,
  vars: Object.create(null),
  enumList: [], enumIdx: -1
};
function clsKey(cls, ev){ return cls.join('.')+'.'+ev; }

function installScript(f,g,s,ev, ops){ const k=clsKey([f,g,s],ev); Scriptorium.set(k, ops); clog(`SCRP installed ${k} (${ops.length} op(s))`); }
function removeScript(f,g,s,ev){ const k=clsKey([f,g,s],ev); Scriptorium.delete(k); clog(`RSCR removed ${k}`); }

function dispatchEventTo(agent, ev, p1, p2, from=null){
  const [f,g,s] = agent.classifier;
  const k=clsKey([f,g,s],ev);
  const ops = Scriptorium.get(k) || Scriptorium.get(clsKey([f,g,0],ev)) || Scriptorium.get(clsKey([f,0,0],ev));
  if(!ops){ clog(`No script for ${k}`); return; }
  const prev = {targ:VMState.targ, own:VMState.own, from:VMState.from};
  VMState.targ = agent; VMState.own = agent; VMState.from = from;
  runOps(ops);
  VMState.targ = prev.targ; VMState.own = prev.own; VMState.from = prev.from;
}

function runOps(ops){
  let ip=0; const stack=[]; // tiny stack for values
  function asNum(x){ if(typeof x==='number') return x; if(typeof x==='string' && /^-?\d+(\.\d+)?$/.test(x)) return Number(x); return 0; }
  function getVar(name){ return VMState.vars[name]||0; }
  function setVar(name,v){ VMState.vars[name]=v; }
  while(ip<ops.length){
    const op = ops[ip++];
    const a = op.args;
    switch(op.op){
      case 'LOG': clog(a.join(' ')); break;
      case 'TARG':
        if(a[0]==='OWN' || a[0]==='OWNR') VMState.targ = VMState.own;
        else if(typeof a[0]==='number') VMState.targ = agents.get(a[0])||null;
        break;
      case 'ATTR':
        if(VMState.targ) VMState.targ.attrs = asNum(a[0]); break;
      case 'TICK':
        if(VMState.targ){ VMState.targ.tick = asNum(a[0]); ensureTimer(VMState.targ); } break;
      case 'POSE':
        if(VMState.targ && VMState.targ.frames){ VMState.targ.frameIdx = asNum(a[0])|0; } break;
      case 'ANIM':
        // For demo, accept single number -> set frame; array unimplemented
        if(VMState.targ && VMState.targ.frames){ VMState.targ.frameIdx = asNum(a[0])|0; } break;
      case 'MVTO':
        if(VMState.targ){ VMState.targ.x = asNum(a[0]); VMState.targ.y = asNum(a[1]); place(VMState.targ); } break;
      case 'MESG_WRIT': { // mesg writ from to ev p1 p2
        const src = (a[0]==='OWN')? VMState.own : (a[0]==='TARG')? VMState.targ : agents.get(asNum(a[0]));
        const dst = (a[1]==='OWN')? VMState.own : (a[1]==='TARG')? VMState.targ : agents.get(asNum(a[1]));
        const evn = asNum(a[2])|0; const p1=asNum(a[3])|0; const p2=asNum(a[4])|0;
        if(dst) dispatchEventTo(dst, evn, p1, p2, src||null);
        break;
      }
      case 'ENUM': { // enum f g s
        const f=asNum(a[0]), g=asNum(a[1]), s=asNum(a[2]);
        VMState.enumList = Array.from(agents.values()).filter(o=> (f===o.classifier[0] || f===-1) && (g===o.classifier[1] || g===-1) && (s===o.classifier[2] || s===-1)).map(o=>o.id);
        VMState.enumIdx = -1;
        break;
      }
      case 'NEAR': { // near radius -> fills enumList by distance from TARG
        const r = asNum(a[0]); const tx=VMState.targ?VMState.targ.x:0, ty=VMState.targ?VMState.targ.y:0;
        VMState.enumList = Array.from(agents.values()).filter(o=>Math.hypot(o.x-tx, o.y-ty)<=r).map(o=>o.id);
        VMState.enumIdx = -1;
        break;
      }
      case 'NEXT': {
        VMState.enumIdx++;
        if(VMState.enumIdx >= VMState.enumList.length){ /* end enumeration */ }
        else { const id = VMState.enumList[VMState.enumIdx]; VMState.targ = agents.get(id)||VMState.targ; }
        break;
      }
      case 'SETV':
        setVar(String(a[0]).toLowerCase(), asNum(a[1])); break;
      case 'ADDV':
        setVar(String(a[0]).toLowerCase(), getVar(String(a[0]).toLowerCase()) + asNum(a[1])); break;
      case 'SUBV':
        setVar(String(a[0]).toLowerCase(), getVar(String(a[0]).toLowerCase()) - asNum(a[1])); break;
      case 'WAIT': // in ticks; for simplicity we noop
        break;
      default:
        clog('NYI: '+op.op+' '+(a||[]).join(' '));
    }
  }
}

function ensureTimer(a){
  if(a._timer) return;
  a._timer = setInterval(()=>{
    if(a.tick>0) dispatchEventTo(a, 9, 0,0);
  }, 250); // rough DS-ish cadence
}

// ----------------- Parser -----------------
function tokenize(text){
  const lines = text.split(/\r?\n/);
  const toks = [];
  for(const raw of lines){
    const line = raw.replace(/;.*/,'').trim(); // strip comments starting with ;
    if(!line) continue;
    const parts = []; let i=0;
    while(i<line.length){
      const ch=line[i];
      if(/\s/.test(ch)){ i++; continue; }
      if(ch=='"'){ let j=i+1, s=''; while(j<line.length && line[j]!='"'){ s+=line[j++]; } parts.push(s); i=j+1; continue; }
      let j=i; while(j<line.length && !/\s/.test(line[j])) j++;
      parts.push(line.slice(i,j)); i=j;
    }
    toks.push(parts);
  }
  return toks;
}

function parseOps(toks){
  const ops=[]; let mode='normal'; let scrp = null;
  function push(op,args){ if(scrp) scrp.ops.push({op,args}); else ops.push({op,args}); }
  for(const ts of toks){
    const head = ts[0].toUpperCase();
    const args = ts.slice(1);
    if(head==='SCRP' || head==='SCRX'){ // scrp family genus species event
      if(scrp) { clog('Nested SCRP not allowed; closing previous.'); installScript(scrp.f, scrp.g, scrp.s, scrp.ev, scrp.ops); }
      scrp = { f:+args[0], g:+args[1], s:+args[2], ev:+args[3], ops:[] };
      continue;
    }
    if(head==='ENDM'){
      if(scrp){ installScript(scrp.f, scrp.g, scrp.s, scrp.ev, scrp.ops); scrp=null; continue; }
    }
    if(head==='RSCR' || head==='SCRX'){
      removeScript(+args[0], +args[1], +args[2], +args[3]);
      continue;
    }
    // map commands
    switch(head){
      case 'LOG': push('LOG', args); break;
      case 'TARG': push('TARG', args.map(x=> x.toUpperCase()==='OWN'?'OWN' : (/^\d+$/.test(x)? +x : x))); break;
      case 'OWN': push('TARG',['OWN']); break;
      case 'ATTR': push('ATTR', [ +args[0] ]); break;
      case 'TICK': push('TICK', [ +args[0] ]); break;
      case 'POSE': push('POSE', [ +args[0] ]); break;
      case 'ANIM': push('ANIM', [ +args[0] ]); break;
      case 'MVTO': push('MVTO', [ +args[0], +args[1] ]); break;
      case 'MESG':
        if(args[0] && args[0].toUpperCase()==='WRIT'){
          const from = (args[1]||'OWN').toUpperCase();
          const to = (args[2]||'TARG').toUpperCase();
          const ev = +args[3]; const p1=+(args[4]||0); const p2=+(args[5]||0);
          push('MESG_WRIT', [from, to, ev, p1, p2]);
        }
        break;
      case 'ENUM':
        push('ENUM', [ +args[0], +args[1], +args[2] ]); break;
      case 'NEAR':
        push('NEAR', [ +args[0] ]); break;
      case 'NEXT':
        push('NEXT', []); break;
      case 'SETV':
        push('SETV', [ args[0], +args[1] ]); break;
      case 'ADDV':
        push('ADDV', [ args[0], +args[1] ]); break;
      case 'SUBV':
        push('SUBV', [ args[0], +args[1] ]); break;
      case 'WAIT':
        push('WAIT', [ +args[0] ]); break;
      default:
        push('LOG', ['NYI', head, ...args]);
    }
  }
  if(scrp) installScript(scrp.f, scrp.g, scrp.s, scrp.ev, scrp.ops);
  return ops;
}

// Console + loader
$('#runOne').onclick = ()=>{
  const t = $('#caos').value.trim();
  const toks = tokenize(t.includes('\n')? t.split('\n')[0] : t);
  parseOps(toks);
  clog('Ran one line.');
};
$('#runBlk').onclick = ()=>{
  const t = $('#caos').value;
  const toks = tokenize(t);
  const ops = parseOps(toks);
  if(ops.length) runOps(ops);
  clog('Ran block.');
};
$('#cosFile').addEventListener('change', async (ev)=>{
  const f = ev.target.files && ev.target.files[0]; if(!f) return;
  const txt = await f.text();
  $('#caos').value = txt;
  clog('Loaded '+f.name+' ('+txt.length+' chars). Click "Run Block".');
});

// TIMER pump for all agents
setInterval(()=>{
  for(const a of agents.values()){
    if(a.tick>0) dispatchEventTo(a, 9, 0,0);
  }
}, 500);

log('v0.11 ready — CAOS core (SCRP/ENDM, MESG WRIT, OWN/TARG, ENUM/NEAR, ATTR, TICK/Timer, POSE/MVTO), BLK/C16/S16/ATT.');
</script>
</body>
</html>
