<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>DSE Web Engine v0.9 — Backgrounds (.blk) + Sprites (.c16/.s16)</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
body{margin:0;background:#0b1020;color:#e5e7eb;font:14px/1.45 system-ui,Segoe UI,Roboto,Arial}
header{padding:12px 16px;display:flex;gap:12px;align-items:center;background:#0a0f1e;border-bottom:1px solid #1f2937;position:sticky;top:0;z-index:10}
.badge{font-size:12px;padding:2px 8px;border-radius:999px;background:#172554;color:#93c5fd;border:1px solid #1e3a8a}
main{display:grid;grid-template-columns:420px 1fr;gap:12px;padding:12px}
.card{background:#0c1326;border:1px solid #1f2937;border-radius:14px;padding:12px}
h2{font-size:16px;margin:0 0 8px 0;color:#cbd5e1}
.btn{background:#0ea5e9;color:#03111f;border:none;font-weight:700;padding:8px 12px;border-radius:10px;cursor:pointer}
.btn:disabled{opacity:.5;cursor:not-allowed}
.row{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
.pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #334155;color:#93c5fd}
.ok{color:#22c55e}.bad{color:#ef4444}
.log{white-space:pre-wrap;background:#0b1020;border:1px solid #1f2937;border-radius:12px;padding:10px;min-height:140px}
.small{font-size:12px;color:#93a1b1}
select{background:#0b1020;color:#e5e7eb;border:1px solid #1e293b;border-radius:8px;padding:6px 8px;min-width:220px}
#world{position:relative;width:100%;height:640px;background:#0b132b;border:1px solid #1e293b;border-radius:12px;overflow:hidden}
#bg{position:absolute;left:0;top:0;image-rendering:pixelated}
#grid{position:absolute;left:0;top:0;image-rendering:pixelated}
.agent{position:absolute;user-select:none;cursor:pointer}
.agent .box{position:absolute;border:1px dashed #64748b;inset:0;pointer-events:none}
</style>
</head>
<body>
<header>
  <div>DSE Web Engine</div>
  <span class="badge">v0.9</span>
  <span class="small">Folder access • BLK background • C16/S16 sprites</span>
</header>

<main>
  <aside class="card">
    <h2>Assets</h2>
    <div class="row">
      <button class="btn" id="pick">Choose Docking Station Folder</button>
      <span id="pickStatus" class="pill">—</span>
    </div>
    <div class="small">Looks for <code>Backgrounds/</code> (.blk) and <code>Images/</code> (.c16/.s16); falls back to a recursive scan.</div>

    <h2 style="margin-top:10px">Background (.blk)</h2>
    <div class="row">
      <select id="bgList"></select>
      <button class="btn" id="loadBg" disabled>Load Background</button>
      <span id="bgStatus" class="pill">—</span>
    </div>

    <h2 style="margin-top:10px">Sprite (.c16/.s16)</h2>
    <div class="row">
      <select id="sprList"></select>
      <button class="btn" id="spawnSprite" disabled>Spawn Sprite</button>
      <span id="sprStatus" class="pill">—</span>
    </div>

    <h2 style="margin-top:10px">Logs</h2>
    <div id="log" class="log"></div>
  </aside>

  <section class="card">
    <h2>World</h2>
    <div id="world">
      <canvas id="bg"></canvas>
      <canvas id="grid"></canvas>
    </div>
  </section>
</main>

<script>
const $ = s=>document.querySelector(s);
const log = m=>{ const el=$('#log'); el.textContent += m + "\\n"; el.scrollTop=el.scrollHeight; };

// canvases
const world = $('#world');
const bg = $('#bg'); const bctx = bg.getContext('2d', { willReadFrequently:true });
const grid = $('#grid'); const gctx = grid.getContext('2d', { willReadFrequently:true });
function resize(){ bg.width=grid.width=world.clientWidth; bg.height=grid.height=world.clientHeight; drawGrid(); }
function drawGrid(){ gctx.clearRect(0,0,grid.width,grid.height); gctx.strokeStyle='#18233d'; for(let x=0;x<grid.width;x+=32){gctx.beginPath();gctx.moveTo(x,0);gctx.lineTo(x,grid.height);gctx.stroke();} for(let y=0;y<grid.height;y+=32){gctx.beginPath();gctx.moveTo(0,y);gctx.lineTo(grid.width,y);gctx.stroke();} }
addEventListener('resize', resize); resize();

// FS Access — directory picker and recursive indexing
let rootHandle = null;
let imagesDir = null, backgroundsDir = null;
const sprites = new Map(); // name -> handle
const backgrounds = new Map(); // name -> handle

async function* walk(dir) {
  for await (const [name, handle] of dir.entries()) {
    if (handle.kind === 'directory') {
      yield* walk(handle);
    } else {
      yield [name, handle];
    }
  }
}

async function chooseFolder(){
  try{
    rootHandle = await window.showDirectoryPicker();
  }catch(e){
    log('Folder selection cancelled'); return;
  }
  $('#pickStatus').textContent='OK'; $('#pickStatus').classList.add('ok');

  async function getDir(name){
    try{ return await rootHandle.getDirectoryHandle(name); }catch{ return null; }
  }
  imagesDir = await getDir('Images') || await getDir('Docking Station')?.then(d=>d.getDirectoryHandle('Images').catch(()=>null)).catch(()=>null);
  backgroundsDir = await getDir('Backgrounds') || await getDir('Docking Station')?.then(d=>d.getDirectoryHandle('Backgrounds').catch(()=>null)).catch(()=>null);

  sprites.clear(); backgrounds.clear();
  async function indexDir(dir, acc, exts){
    if(!dir) return;
    for await (const [name, handle] of walk(dir)){
      const low = name.toLowerCase();
      if (exts.some(ext=>low.endsWith(ext))) acc.set(name, handle);
    }
  }
  await indexDir(imagesDir, sprites, ['.c16','.s16']);
  await indexDir(backgroundsDir, backgrounds, ['.blk']);

  // fallback: scan entire tree if needed
  if(sprites.size===0 || backgrounds.size===0){
    for await (const [name, handle] of walk(rootHandle)){
      const low=name.toLowerCase();
      if(low.endsWith('.c16')||low.endsWith('.s16')) sprites.set(name, handle);
      if(low.endsWith('.blk')) backgrounds.set(name, handle);
    }
  }

  // populate selects
  const bgList = $('#bgList'); const sprList = $('#sprList');
  bgList.innerHTML=''; sprList.innerHTML='';
  [...backgrounds.keys()].sort().forEach(n=>{ const o=document.createElement('option'); o.value=o.textContent=n; bgList.appendChild(o); });
  [...sprites.keys()].sort().forEach(n=>{ const o=document.createElement('option'); o.value=o.textContent=n; sprList.appendChild(o); });
  $('#loadBg').disabled = backgrounds.size===0;
  $('#spawnSprite').disabled = sprites.size===0;

  log(`Indexed: ${backgrounds.size} background(s), ${sprites.size} sprite file(s).`);
}

$('#pick').onclick = chooseFolder;

// helpers: read file into ArrayBuffer
async function readFile(handle){
  const f = await handle.getFile();
  return await f.arrayBuffer();
}

// pixel unpackers
function toRGBA555(px){
  const r=((px>>10)&31)*255/31;
  const g=((px>>5)&31)*255/31;
  const b=(px&31)*255/31;
  return [r|0,g|0,b|0,255];
}
function toRGBA565(px){
  const r=((px>>11)&31)*255/31;
  const g=((px>>5)&63)*255/63;
  const b=(px&31)*255/31;
  return [r|0,g|0,b|0,255];
}

// S16 decode
function decodeS16(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength);
  let p=0;
  const fmt=dv.getUint32(p,true); p+=4;
  const pix = (fmt===0)? toRGBA555 : (fmt===1)? toRGBA565 : toRGBA565;
  const count=dv.getUint16(p,true); p+=2;
  const headers=[];
  for(let i=0;i<count;i++){ const off=dv.getUint32(p,true); p+=4; const w=dv.getUint16(p,true); p+=2; const h=dv.getUint16(p,true); p+=2; headers.push({off,w,h}); }
  const imgs=[];
  for(const H of headers){
    let q=H.off; const id=new ImageData(H.w,H.h);
    for(let i=0;i<H.w*H.h;i++){ const px=dv.getUint16(q,true); q+=2; const [r,g,b,a]=pix(px); const j=i*4; id.data[j]=r; id.data[j+1]=g; id.data[j+2]=b; id.data[j+3]=a; }
    imgs.push(id);
  }
  return imgs;
}

// C16 decode
function decodeC16(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength);
  let p=0;
  const fmt=dv.getUint32(p,true); p+=4;
  const pix = (fmt===2)? toRGBA555 : (fmt===3)? toRGBA565 : toRGBA565;
  const count=dv.getUint16(p,true); p+=2;
  const headers=[];
  for(let i=0;i<count;i++){
    const off=dv.getUint32(p,true); p+=4; const w=dv.getUint16(p,true); p+=2; const h=dv.getUint16(p,true); p+=2;
    const lineOffsets=[]; for(let y=1;y<h;y++) lineOffsets.push(dv.getUint32(p,true)), p+=4;
    headers.push({off,w,h});
  }
  const imgs=[];
  for(const H of headers){
    let q=H.off;
    const id=new ImageData(H.w,H.h);
    for(let y=0;y<H.h;y++){
      let filled=0;
      for(;;){
        const tag=dv.getUint16(q,true); q+=2;
        if(tag===0) break;
        const runType = tag & 1;
        const runLen  = tag >> 1;
        if(runType===1){
          for(let i=0;i<runLen;i++){
            const px=dv.getUint16(q,true); q+=2;
            const [r,g,b,a]=pix(px);
            const j=(y*H.w + filled + i)*4;
            id.data[j]=r; id.data[j+1]=g; id.data[j+2]=b; id.data[j+3]=a;
          }
        }else{
          for(let i=0;i<runLen;i++){
            const j=(y*H.w + filled + i)*4;
            id.data[j]=0; id.data[j+1]=0; id.data[j+2]=0; id.data[j+3]=0;
          }
        }
        filled += runLen;
        if (filled>=H.w) {}
      }
    }
    imgs.push(id);
  }
  return imgs;
}

// BLK decode
function decodeBLK(u8){
  const dv=new DataView(u8.buffer,u8.byteOffset,u8.byteLength);
  let p=0;
  const fmt=dv.getUint32(p,true); p+=4;
  const pix = (fmt===0)? toRGBA555 : (fmt===1)? toRGBA565 : toRGBA565;
  const bw=dv.getUint16(p,true); p+=2;
  const bh=dv.getUint16(p,true); p+=2;
  const num=dv.getUint16(p,true); p+=2;
  const headers=[];
  for(let i=0;i<num;i++){
    const offMinus4=dv.getUint32(p,true); p+=4;
    const w=dv.getUint16(p,true); p+=2;
    const h=dv.getUint16(p,true); p+=2;
    headers.push({off:offMinus4+4, w, h});
  }
  const tiles=[];
  for(const H of headers){
    let q=H.off; const id=new ImageData(H.w,H.h);
    for(let i=0;i<H.w*H.h;i++){ const px=dv.getUint16(q,true); q+=2; const [r,g,b,a]=pix(px); const j=i*4; id.data[j]=r; id.data[j+1]=g; id.data[j+2]=b; id.data[j+3]=a; }
    tiles.push(id);
  }
  const tileW=headers[0]?.w||128, tileH=headers[0]?.h||128;
  const bigW=bw*tileW, bigH=bh*tileH;
  const cnv=document.createElement('canvas'); cnv.width=bigW; cnv.height=bigH; const c=cnv.getContext('2d');
  let idx=0;
  for(let cx=0; cx<bw; cx++){
    for(let cy=0; cy<bh; cy++){
      const t=tiles[idx++]; if(!t) continue;
      c.putImageData(t, cx*tileW, cy*tileH);
    }
  }
  return cnv;
}

// Background hook
$('#loadBg').onclick = async ()=>{
  const name = $('#bgList').value; if(!name){ alert('Pick a .blk'); return; }
  const handle = backgrounds.get(name);
  const buf = await readFile(handle);
  const cnv = decodeBLK(new Uint8Array(buf));
  bg.width = cnv.width; bg.height = cnv.height;
  bctx.clearRect(0,0,bg.width,bg.height);
  bctx.drawImage(cnv,0,0);
  $('#bgStatus').textContent='PASS'; $('#bgStatus').classList.add('ok');
  log(`Background loaded: ${name} (${bg.width}×${bg.height})`);
};

// Agents & sprites
let NEXT_ID=1; const agents = new Map();
function place(a){ a.el.style.left=a.x+'px'; a.el.style.top=a.y+'px'; }
function addAgent(x,y,w,h){
  const id=NEXT_ID++; const el=document.createElement('div'); el.className='agent';
  el.style.left=x+'px'; el.style.top=y+'px'; el.style.width=w+'px'; el.style.height=h+'px';
  const box=document.createElement('div'); box.className='box'; el.appendChild(box);
  world.appendChild(el);
  const a={id,el,x,y,w,h,held:false}; agents.set(id,a);
  el.addEventListener('mousedown', e=>{a.held=true; a.hx=e.offsetX; a.hy=e.offsetY;});
  addEventListener('mousemove', e=>{ if(!a.held) return; const r=world.getBoundingClientRect(); a.x=e.clientX-r.left-a.hx; a.y=e.clientY-r.top-a.hy; place(a); });
  addEventListener('mouseup', ()=>{ if(!a.held) return; a.held=false; });
  place(a); return a;
}

async function decodeSpriteFile(handle){
  const ab = await readFile(handle);
  const u8 = new Uint8Array(ab);
  const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
  const sig = dv.getUint32(0,true);
  if(sig===2 || sig===3) return decodeC16(u8);
  if(sig===0 || sig===1) return decodeS16(u8);
  throw new Error('Unknown sprite signature: '+sig);
}

$('#spawnSprite').onclick = async ()=>{
  const name = $('#sprList').value; if(!name){ alert('Pick a .c16/.s16'); return; }
  const handle = sprites.get(name);
  try{
    const frames = await decodeSpriteFile(handle);
    if(frames.length===0) throw new Error('No frames decoded');
    const w = frames[0].width, h = frames[0].height;
    const a = addAgent(80,80,w,h);
    let i=0;
    const cnv=document.createElement('canvas'); cnv.width=w; cnv.height=h; const c=cnv.getContext('2d');
    function step(){ c.putImageData(frames[i%frames.length],0,0); const url=cnv.toDataURL(); a.el.style.background=`url(${url})`; a.el.style.backgroundSize='cover'; i++; }
    step(); a.timer = setInterval(step, 160);
    $('#sprStatus').textContent='PASS'; $('#sprStatus').classList.add('ok');
    log(`Spawned sprite from ${name} with ${frames.length} frame(s). Drag it around.`);
  }catch(err){
    log('Sprite load error: '+err.message);
    $('#sprStatus').textContent='FAIL'; $('#sprStatus').classList.add('bad');
  }
};

log('v0.9 ready — click “Choose Docking Station Folder”.');
</script>
</body>
</html>
